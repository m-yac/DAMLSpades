
daml 1.2
module Spades where

import DA.Action.State
import DA.List


-- The standard deck of cards

data Suit = S | C | H | D
  deriving (Eq, Show)

data Card = Card with
  value : Int
  suit  : Suit
    deriving (Eq)

-- use this function rather than the `Card` constructor when making cards
card : Int -> Suit -> Card
card v s | v >= 1 && v <= 13 = Card v s
         | otherwise = error "malformed card"

instance Show Card where
  show (Card v s) = show v <> " " <> show s

-- a standard 52-card deck
deck : [Card]
deck = card <$> [1..13] <*> [S,C,H,D]


-- Randomness and shuffling

bitshift : Int -> Int -> Int
bitshift x amt | amt >= 0  = x * 2^amt
               | otherwise = truncate (intToDecimal x / 2.0^amt)

-- source: Marsaglia, George 'Xorshift RNGs'
xorshift : Int -> Int
xorshift = doXorSh 17 . doXorSh (-7) . doXorSh 13
  where doXorSh shamt x = x ^ (bitshift x shamt)

type Random a = State Int a

-- returns a random integer in the given range [lo,hi)
randomInt : (Int,Int) -> Random Int
randomInt (lo,hi) = do
  modify xorshift -- advance the seed
  result <- get
  pure (lo + result % (hi - lo))

runWithSeed : Random a -> Int -> a
runWithSeed = evalState

-- randomly shuffles a list
shuffle : [a] -> Random [a]
shuffle [] = pure []
shuffle (x::xs) = do
  i <- randomInt (0, length xs)
  (ls,hs) <- splitAt i <$> (shuffle xs)
  pure (ls ++ [x] ++ hs)


-- Tricks and scoring

-- A spade always trumps a non-spade, a card of the lead suit always trumps all
--  non-spades, and otherwise cards are compared by their values
compareWithLead : Suit -> Card -> Card -> Ordering
compareWithLead sl (Card v1 s1) (Card v2 s2)
  = let scmp = compare (suitToInt s1) (suitToInt s2)
     in if scmp == EQ then compare v1 v2 else scmp
  where suitToInt : Suit -> Int
        suitToInt s | s == S    = 2
                    | s == sl   = 1
                    | otherwise = 0

-- from GHC Prelude
maximumBy : (a -> a -> Ordering) -> [a] -> a
maximumBy f = foldl1 (\x y -> if f x y == GT then x else y)

type Trick = [Card]

-- returns the index of the player who won the given trick, using `compareWithLead`
trickWinner : Trick -> Int
trickWinner (cl::cs) = snd $ maximumBy (\(c1,_) (c2,_) -> compareWithLead (suit cl) c1 c2) (zip (cl::cs) [0..])
trickWinner _ = error "trickWinner: empty list"

score : Int -> Int -> Int
score bet won | bet < 0 || bet > 13 = error $ "invalid bet: " <> show bet 
              | won < 0 || won > 13 = error $ "invalid number of wins: " <> show won
              | bet == 0 && won == 0 = 100
              | bet == 0 && won >= 1 = -100
              | won >= bet           = 10*bet + (won - bet)
              | otherwise            = -10*bet
